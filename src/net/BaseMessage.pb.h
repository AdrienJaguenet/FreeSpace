// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BaseMessage.proto

#ifndef PROTOBUF_INCLUDED_BaseMessage_2eproto
#define PROTOBUF_INCLUDED_BaseMessage_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_BaseMessage_2eproto 

namespace protobuf_BaseMessage_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_BaseMessage_2eproto
class Base;
class BaseDefaultTypeInternal;
extern BaseDefaultTypeInternal _Base_default_instance_;
class HealthComponentUpdate;
class HealthComponentUpdateDefaultTypeInternal;
extern HealthComponentUpdateDefaultTypeInternal _HealthComponentUpdate_default_instance_;
class PhysicsComponentUpdate;
class PhysicsComponentUpdateDefaultTypeInternal;
extern PhysicsComponentUpdateDefaultTypeInternal _PhysicsComponentUpdate_default_instance_;
class ProjectileComponentUpdate;
class ProjectileComponentUpdateDefaultTypeInternal;
extern ProjectileComponentUpdateDefaultTypeInternal _ProjectileComponentUpdate_default_instance_;
class ResourceComponentUpdate;
class ResourceComponentUpdateDefaultTypeInternal;
extern ResourceComponentUpdateDefaultTypeInternal _ResourceComponentUpdate_default_instance_;
class ResourceTypeUpdate;
class ResourceTypeUpdateDefaultTypeInternal;
extern ResourceTypeUpdateDefaultTypeInternal _ResourceTypeUpdate_default_instance_;
class UpdatedEntity;
class UpdatedEntityDefaultTypeInternal;
extern UpdatedEntityDefaultTypeInternal _UpdatedEntity_default_instance_;
class UpdatedEntityList;
class UpdatedEntityListDefaultTypeInternal;
extern UpdatedEntityListDefaultTypeInternal _UpdatedEntityList_default_instance_;
namespace google {
namespace protobuf {
template<> ::Base* Arena::CreateMaybeMessage<::Base>(Arena*);
template<> ::HealthComponentUpdate* Arena::CreateMaybeMessage<::HealthComponentUpdate>(Arena*);
template<> ::PhysicsComponentUpdate* Arena::CreateMaybeMessage<::PhysicsComponentUpdate>(Arena*);
template<> ::ProjectileComponentUpdate* Arena::CreateMaybeMessage<::ProjectileComponentUpdate>(Arena*);
template<> ::ResourceComponentUpdate* Arena::CreateMaybeMessage<::ResourceComponentUpdate>(Arena*);
template<> ::ResourceTypeUpdate* Arena::CreateMaybeMessage<::ResourceTypeUpdate>(Arena*);
template<> ::UpdatedEntity* Arena::CreateMaybeMessage<::UpdatedEntity>(Arena*);
template<> ::UpdatedEntityList* Arena::CreateMaybeMessage<::UpdatedEntityList>(Arena*);
}  // namespace protobuf
}  // namespace google

enum UpdatedEntity_UpdateType {
  UpdatedEntity_UpdateType_CREATE = 1,
  UpdatedEntity_UpdateType_UPDATE = 2,
  UpdatedEntity_UpdateType_DELETE = 3
};
bool UpdatedEntity_UpdateType_IsValid(int value);
const UpdatedEntity_UpdateType UpdatedEntity_UpdateType_UpdateType_MIN = UpdatedEntity_UpdateType_CREATE;
const UpdatedEntity_UpdateType UpdatedEntity_UpdateType_UpdateType_MAX = UpdatedEntity_UpdateType_DELETE;
const int UpdatedEntity_UpdateType_UpdateType_ARRAYSIZE = UpdatedEntity_UpdateType_UpdateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UpdatedEntity_UpdateType_descriptor();
inline const ::std::string& UpdatedEntity_UpdateType_Name(UpdatedEntity_UpdateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UpdatedEntity_UpdateType_descriptor(), value);
}
inline bool UpdatedEntity_UpdateType_Parse(
    const ::std::string& name, UpdatedEntity_UpdateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UpdatedEntity_UpdateType>(
    UpdatedEntity_UpdateType_descriptor(), name, value);
}
enum MessageType {
  Hello = 1,
  Disconnect = 2,
  UpdateEntity = 3
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = Hello;
const MessageType MessageType_MAX = UpdateEntity;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class Base : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Base) */ {
 public:
  Base();
  virtual ~Base();

  Base(const Base& from);

  inline Base& operator=(const Base& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Base(Base&& from) noexcept
    : Base() {
    *this = ::std::move(from);
  }

  inline Base& operator=(Base&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Base& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Base* internal_default_instance() {
    return reinterpret_cast<const Base*>(
               &_Base_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Base* other);
  friend void swap(Base& a, Base& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Base* New() const final {
    return CreateMaybeMessage<Base>(NULL);
  }

  Base* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Base>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Base& from);
  void MergeFrom(const Base& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Base* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes msg = 2;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 2;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  #if LANG_CXX11
  void set_msg(::std::string&& value);
  #endif
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // optional .MessageType messageType = 1;
  bool has_messagetype() const;
  void clear_messagetype();
  static const int kMessageTypeFieldNumber = 1;
  ::MessageType messagetype() const;
  void set_messagetype(::MessageType value);

  // @@protoc_insertion_point(class_scope:Base)
 private:
  void set_has_messagetype();
  void clear_has_messagetype();
  void set_has_msg();
  void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  int messagetype_;
  friend struct ::protobuf_BaseMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PhysicsComponentUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PhysicsComponentUpdate) */ {
 public:
  PhysicsComponentUpdate();
  virtual ~PhysicsComponentUpdate();

  PhysicsComponentUpdate(const PhysicsComponentUpdate& from);

  inline PhysicsComponentUpdate& operator=(const PhysicsComponentUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PhysicsComponentUpdate(PhysicsComponentUpdate&& from) noexcept
    : PhysicsComponentUpdate() {
    *this = ::std::move(from);
  }

  inline PhysicsComponentUpdate& operator=(PhysicsComponentUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PhysicsComponentUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PhysicsComponentUpdate* internal_default_instance() {
    return reinterpret_cast<const PhysicsComponentUpdate*>(
               &_PhysicsComponentUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(PhysicsComponentUpdate* other);
  friend void swap(PhysicsComponentUpdate& a, PhysicsComponentUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PhysicsComponentUpdate* New() const final {
    return CreateMaybeMessage<PhysicsComponentUpdate>(NULL);
  }

  PhysicsComponentUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PhysicsComponentUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PhysicsComponentUpdate& from);
  void MergeFrom(const PhysicsComponentUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PhysicsComponentUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float yaw = 1;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 1;
  float yaw() const;
  void set_yaw(float value);

  // optional float radius = 2;
  bool has_radius() const;
  void clear_radius();
  static const int kRadiusFieldNumber = 2;
  float radius() const;
  void set_radius(float value);

  // optional float speed = 3;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  float speed() const;
  void set_speed(float value);

  // optional bool isColliding = 4;
  bool has_iscolliding() const;
  void clear_iscolliding();
  static const int kIsCollidingFieldNumber = 4;
  bool iscolliding() const;
  void set_iscolliding(bool value);

  // optional float velX = 5;
  bool has_velx() const;
  void clear_velx();
  static const int kVelXFieldNumber = 5;
  float velx() const;
  void set_velx(float value);

  // optional float velY = 6;
  bool has_vely() const;
  void clear_vely();
  static const int kVelYFieldNumber = 6;
  float vely() const;
  void set_vely(float value);

  // optional float posX = 7;
  bool has_posx() const;
  void clear_posx();
  static const int kPosXFieldNumber = 7;
  float posx() const;
  void set_posx(float value);

  // optional float posY = 8;
  bool has_posy() const;
  void clear_posy();
  static const int kPosYFieldNumber = 8;
  float posy() const;
  void set_posy(float value);

  // @@protoc_insertion_point(class_scope:PhysicsComponentUpdate)
 private:
  void set_has_yaw();
  void clear_has_yaw();
  void set_has_radius();
  void clear_has_radius();
  void set_has_speed();
  void clear_has_speed();
  void set_has_iscolliding();
  void clear_has_iscolliding();
  void set_has_velx();
  void clear_has_velx();
  void set_has_vely();
  void clear_has_vely();
  void set_has_posx();
  void clear_has_posx();
  void set_has_posy();
  void clear_has_posy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float yaw_;
  float radius_;
  float speed_;
  bool iscolliding_;
  float velx_;
  float vely_;
  float posx_;
  float posy_;
  friend struct ::protobuf_BaseMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProjectileComponentUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ProjectileComponentUpdate) */ {
 public:
  ProjectileComponentUpdate();
  virtual ~ProjectileComponentUpdate();

  ProjectileComponentUpdate(const ProjectileComponentUpdate& from);

  inline ProjectileComponentUpdate& operator=(const ProjectileComponentUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProjectileComponentUpdate(ProjectileComponentUpdate&& from) noexcept
    : ProjectileComponentUpdate() {
    *this = ::std::move(from);
  }

  inline ProjectileComponentUpdate& operator=(ProjectileComponentUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProjectileComponentUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProjectileComponentUpdate* internal_default_instance() {
    return reinterpret_cast<const ProjectileComponentUpdate*>(
               &_ProjectileComponentUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(ProjectileComponentUpdate* other);
  friend void swap(ProjectileComponentUpdate& a, ProjectileComponentUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProjectileComponentUpdate* New() const final {
    return CreateMaybeMessage<ProjectileComponentUpdate>(NULL);
  }

  ProjectileComponentUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProjectileComponentUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProjectileComponentUpdate& from);
  void MergeFrom(const ProjectileComponentUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProjectileComponentUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 damage = 1;
  bool has_damage() const;
  void clear_damage();
  static const int kDamageFieldNumber = 1;
  ::google::protobuf::int32 damage() const;
  void set_damage(::google::protobuf::int32 value);

  // optional int32 originEntity = 2;
  bool has_originentity() const;
  void clear_originentity();
  static const int kOriginEntityFieldNumber = 2;
  ::google::protobuf::int32 originentity() const;
  void set_originentity(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProjectileComponentUpdate)
 private:
  void set_has_damage();
  void clear_has_damage();
  void set_has_originentity();
  void clear_has_originentity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 damage_;
  ::google::protobuf::int32 originentity_;
  friend struct ::protobuf_BaseMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResourceTypeUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ResourceTypeUpdate) */ {
 public:
  ResourceTypeUpdate();
  virtual ~ResourceTypeUpdate();

  ResourceTypeUpdate(const ResourceTypeUpdate& from);

  inline ResourceTypeUpdate& operator=(const ResourceTypeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceTypeUpdate(ResourceTypeUpdate&& from) noexcept
    : ResourceTypeUpdate() {
    *this = ::std::move(from);
  }

  inline ResourceTypeUpdate& operator=(ResourceTypeUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceTypeUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceTypeUpdate* internal_default_instance() {
    return reinterpret_cast<const ResourceTypeUpdate*>(
               &_ResourceTypeUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ResourceTypeUpdate* other);
  friend void swap(ResourceTypeUpdate& a, ResourceTypeUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceTypeUpdate* New() const final {
    return CreateMaybeMessage<ResourceTypeUpdate>(NULL);
  }

  ResourceTypeUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResourceTypeUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResourceTypeUpdate& from);
  void MergeFrom(const ResourceTypeUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceTypeUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string resourceType = 1;
  bool has_resourcetype() const;
  void clear_resourcetype();
  static const int kResourceTypeFieldNumber = 1;
  const ::std::string& resourcetype() const;
  void set_resourcetype(const ::std::string& value);
  #if LANG_CXX11
  void set_resourcetype(::std::string&& value);
  #endif
  void set_resourcetype(const char* value);
  void set_resourcetype(const char* value, size_t size);
  ::std::string* mutable_resourcetype();
  ::std::string* release_resourcetype();
  void set_allocated_resourcetype(::std::string* resourcetype);

  // optional int32 resourceStrength = 2;
  bool has_resourcestrength() const;
  void clear_resourcestrength();
  static const int kResourceStrengthFieldNumber = 2;
  ::google::protobuf::int32 resourcestrength() const;
  void set_resourcestrength(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ResourceTypeUpdate)
 private:
  void set_has_resourcetype();
  void clear_has_resourcetype();
  void set_has_resourcestrength();
  void clear_has_resourcestrength();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr resourcetype_;
  ::google::protobuf::int32 resourcestrength_;
  friend struct ::protobuf_BaseMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResourceComponentUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ResourceComponentUpdate) */ {
 public:
  ResourceComponentUpdate();
  virtual ~ResourceComponentUpdate();

  ResourceComponentUpdate(const ResourceComponentUpdate& from);

  inline ResourceComponentUpdate& operator=(const ResourceComponentUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResourceComponentUpdate(ResourceComponentUpdate&& from) noexcept
    : ResourceComponentUpdate() {
    *this = ::std::move(from);
  }

  inline ResourceComponentUpdate& operator=(ResourceComponentUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceComponentUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResourceComponentUpdate* internal_default_instance() {
    return reinterpret_cast<const ResourceComponentUpdate*>(
               &_ResourceComponentUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ResourceComponentUpdate* other);
  friend void swap(ResourceComponentUpdate& a, ResourceComponentUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResourceComponentUpdate* New() const final {
    return CreateMaybeMessage<ResourceComponentUpdate>(NULL);
  }

  ResourceComponentUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResourceComponentUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResourceComponentUpdate& from);
  void MergeFrom(const ResourceComponentUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResourceComponentUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ResourceTypeUpdate resourceType = 1;
  int resourcetype_size() const;
  void clear_resourcetype();
  static const int kResourceTypeFieldNumber = 1;
  ::ResourceTypeUpdate* mutable_resourcetype(int index);
  ::google::protobuf::RepeatedPtrField< ::ResourceTypeUpdate >*
      mutable_resourcetype();
  const ::ResourceTypeUpdate& resourcetype(int index) const;
  ::ResourceTypeUpdate* add_resourcetype();
  const ::google::protobuf::RepeatedPtrField< ::ResourceTypeUpdate >&
      resourcetype() const;

  // @@protoc_insertion_point(class_scope:ResourceComponentUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ResourceTypeUpdate > resourcetype_;
  friend struct ::protobuf_BaseMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HealthComponentUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:HealthComponentUpdate) */ {
 public:
  HealthComponentUpdate();
  virtual ~HealthComponentUpdate();

  HealthComponentUpdate(const HealthComponentUpdate& from);

  inline HealthComponentUpdate& operator=(const HealthComponentUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HealthComponentUpdate(HealthComponentUpdate&& from) noexcept
    : HealthComponentUpdate() {
    *this = ::std::move(from);
  }

  inline HealthComponentUpdate& operator=(HealthComponentUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HealthComponentUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HealthComponentUpdate* internal_default_instance() {
    return reinterpret_cast<const HealthComponentUpdate*>(
               &_HealthComponentUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(HealthComponentUpdate* other);
  friend void swap(HealthComponentUpdate& a, HealthComponentUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HealthComponentUpdate* New() const final {
    return CreateMaybeMessage<HealthComponentUpdate>(NULL);
  }

  HealthComponentUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HealthComponentUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HealthComponentUpdate& from);
  void MergeFrom(const HealthComponentUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HealthComponentUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 hp = 1;
  bool has_hp() const;
  void clear_hp();
  static const int kHpFieldNumber = 1;
  ::google::protobuf::int32 hp() const;
  void set_hp(::google::protobuf::int32 value);

  // optional int32 maxHp = 2;
  bool has_maxhp() const;
  void clear_maxhp();
  static const int kMaxHpFieldNumber = 2;
  ::google::protobuf::int32 maxhp() const;
  void set_maxhp(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:HealthComponentUpdate)
 private:
  void set_has_hp();
  void clear_has_hp();
  void set_has_maxhp();
  void clear_has_maxhp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 maxhp_;
  friend struct ::protobuf_BaseMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdatedEntity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UpdatedEntity) */ {
 public:
  UpdatedEntity();
  virtual ~UpdatedEntity();

  UpdatedEntity(const UpdatedEntity& from);

  inline UpdatedEntity& operator=(const UpdatedEntity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdatedEntity(UpdatedEntity&& from) noexcept
    : UpdatedEntity() {
    *this = ::std::move(from);
  }

  inline UpdatedEntity& operator=(UpdatedEntity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatedEntity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatedEntity* internal_default_instance() {
    return reinterpret_cast<const UpdatedEntity*>(
               &_UpdatedEntity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(UpdatedEntity* other);
  friend void swap(UpdatedEntity& a, UpdatedEntity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdatedEntity* New() const final {
    return CreateMaybeMessage<UpdatedEntity>(NULL);
  }

  UpdatedEntity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdatedEntity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdatedEntity& from);
  void MergeFrom(const UpdatedEntity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatedEntity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdatedEntity_UpdateType UpdateType;
  static const UpdateType CREATE =
    UpdatedEntity_UpdateType_CREATE;
  static const UpdateType UPDATE =
    UpdatedEntity_UpdateType_UPDATE;
  static const UpdateType DELETE =
    UpdatedEntity_UpdateType_DELETE;
  static inline bool UpdateType_IsValid(int value) {
    return UpdatedEntity_UpdateType_IsValid(value);
  }
  static const UpdateType UpdateType_MIN =
    UpdatedEntity_UpdateType_UpdateType_MIN;
  static const UpdateType UpdateType_MAX =
    UpdatedEntity_UpdateType_UpdateType_MAX;
  static const int UpdateType_ARRAYSIZE =
    UpdatedEntity_UpdateType_UpdateType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  UpdateType_descriptor() {
    return UpdatedEntity_UpdateType_descriptor();
  }
  static inline const ::std::string& UpdateType_Name(UpdateType value) {
    return UpdatedEntity_UpdateType_Name(value);
  }
  static inline bool UpdateType_Parse(const ::std::string& name,
      UpdateType* value) {
    return UpdatedEntity_UpdateType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .HealthComponentUpdate health = 2;
  bool has_health() const;
  void clear_health();
  static const int kHealthFieldNumber = 2;
  private:
  const ::HealthComponentUpdate& _internal_health() const;
  public:
  const ::HealthComponentUpdate& health() const;
  ::HealthComponentUpdate* release_health();
  ::HealthComponentUpdate* mutable_health();
  void set_allocated_health(::HealthComponentUpdate* health);

  // optional .PhysicsComponentUpdate physics = 3;
  bool has_physics() const;
  void clear_physics();
  static const int kPhysicsFieldNumber = 3;
  private:
  const ::PhysicsComponentUpdate& _internal_physics() const;
  public:
  const ::PhysicsComponentUpdate& physics() const;
  ::PhysicsComponentUpdate* release_physics();
  ::PhysicsComponentUpdate* mutable_physics();
  void set_allocated_physics(::PhysicsComponentUpdate* physics);

  // optional .ResourceComponentUpdate resource = 16;
  bool has_resource() const;
  void clear_resource();
  static const int kResourceFieldNumber = 16;
  private:
  const ::ResourceComponentUpdate& _internal_resource() const;
  public:
  const ::ResourceComponentUpdate& resource() const;
  ::ResourceComponentUpdate* release_resource();
  ::ResourceComponentUpdate* mutable_resource();
  void set_allocated_resource(::ResourceComponentUpdate* resource);

  // optional .ProjectileComponentUpdate projectile = 17;
  bool has_projectile() const;
  void clear_projectile();
  static const int kProjectileFieldNumber = 17;
  private:
  const ::ProjectileComponentUpdate& _internal_projectile() const;
  public:
  const ::ProjectileComponentUpdate& projectile() const;
  ::ProjectileComponentUpdate* release_projectile();
  ::ProjectileComponentUpdate* mutable_projectile();
  void set_allocated_projectile(::ProjectileComponentUpdate* projectile);

  // optional int32 entityID = 1;
  bool has_entityid() const;
  void clear_entityid();
  static const int kEntityIDFieldNumber = 1;
  ::google::protobuf::int32 entityid() const;
  void set_entityid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:UpdatedEntity)
 private:
  void set_has_entityid();
  void clear_has_entityid();
  void set_has_health();
  void clear_has_health();
  void set_has_physics();
  void clear_has_physics();
  void set_has_resource();
  void clear_has_resource();
  void set_has_projectile();
  void clear_has_projectile();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::HealthComponentUpdate* health_;
  ::PhysicsComponentUpdate* physics_;
  ::ResourceComponentUpdate* resource_;
  ::ProjectileComponentUpdate* projectile_;
  ::google::protobuf::int32 entityid_;
  friend struct ::protobuf_BaseMessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdatedEntityList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UpdatedEntityList) */ {
 public:
  UpdatedEntityList();
  virtual ~UpdatedEntityList();

  UpdatedEntityList(const UpdatedEntityList& from);

  inline UpdatedEntityList& operator=(const UpdatedEntityList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdatedEntityList(UpdatedEntityList&& from) noexcept
    : UpdatedEntityList() {
    *this = ::std::move(from);
  }

  inline UpdatedEntityList& operator=(UpdatedEntityList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdatedEntityList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdatedEntityList* internal_default_instance() {
    return reinterpret_cast<const UpdatedEntityList*>(
               &_UpdatedEntityList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(UpdatedEntityList* other);
  friend void swap(UpdatedEntityList& a, UpdatedEntityList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdatedEntityList* New() const final {
    return CreateMaybeMessage<UpdatedEntityList>(NULL);
  }

  UpdatedEntityList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdatedEntityList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdatedEntityList& from);
  void MergeFrom(const UpdatedEntityList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdatedEntityList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .UpdatedEntity entities = 1;
  int entities_size() const;
  void clear_entities();
  static const int kEntitiesFieldNumber = 1;
  ::UpdatedEntity* mutable_entities(int index);
  ::google::protobuf::RepeatedPtrField< ::UpdatedEntity >*
      mutable_entities();
  const ::UpdatedEntity& entities(int index) const;
  ::UpdatedEntity* add_entities();
  const ::google::protobuf::RepeatedPtrField< ::UpdatedEntity >&
      entities() const;

  // @@protoc_insertion_point(class_scope:UpdatedEntityList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::UpdatedEntity > entities_;
  friend struct ::protobuf_BaseMessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Base

// optional .MessageType messageType = 1;
inline bool Base::has_messagetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Base::set_has_messagetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Base::clear_has_messagetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Base::clear_messagetype() {
  messagetype_ = 1;
  clear_has_messagetype();
}
inline ::MessageType Base::messagetype() const {
  // @@protoc_insertion_point(field_get:Base.messageType)
  return static_cast< ::MessageType >(messagetype_);
}
inline void Base::set_messagetype(::MessageType value) {
  assert(::MessageType_IsValid(value));
  set_has_messagetype();
  messagetype_ = value;
  // @@protoc_insertion_point(field_set:Base.messageType)
}

// optional bytes msg = 2;
inline bool Base::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Base::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Base::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Base::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_msg();
}
inline const ::std::string& Base::msg() const {
  // @@protoc_insertion_point(field_get:Base.msg)
  return msg_.GetNoArena();
}
inline void Base::set_msg(const ::std::string& value) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Base.msg)
}
#if LANG_CXX11
inline void Base::set_msg(::std::string&& value) {
  set_has_msg();
  msg_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Base.msg)
}
#endif
inline void Base::set_msg(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Base.msg)
}
inline void Base::set_msg(const void* value, size_t size) {
  set_has_msg();
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Base.msg)
}
inline ::std::string* Base::mutable_msg() {
  set_has_msg();
  // @@protoc_insertion_point(field_mutable:Base.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Base::release_msg() {
  // @@protoc_insertion_point(field_release:Base.msg)
  if (!has_msg()) {
    return NULL;
  }
  clear_has_msg();
  return msg_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Base::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:Base.msg)
}

// -------------------------------------------------------------------

// PhysicsComponentUpdate

// optional float yaw = 1;
inline bool PhysicsComponentUpdate::has_yaw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PhysicsComponentUpdate::set_has_yaw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PhysicsComponentUpdate::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PhysicsComponentUpdate::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float PhysicsComponentUpdate::yaw() const {
  // @@protoc_insertion_point(field_get:PhysicsComponentUpdate.yaw)
  return yaw_;
}
inline void PhysicsComponentUpdate::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:PhysicsComponentUpdate.yaw)
}

// optional float radius = 2;
inline bool PhysicsComponentUpdate::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PhysicsComponentUpdate::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PhysicsComponentUpdate::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PhysicsComponentUpdate::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float PhysicsComponentUpdate::radius() const {
  // @@protoc_insertion_point(field_get:PhysicsComponentUpdate.radius)
  return radius_;
}
inline void PhysicsComponentUpdate::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:PhysicsComponentUpdate.radius)
}

// optional float speed = 3;
inline bool PhysicsComponentUpdate::has_speed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PhysicsComponentUpdate::set_has_speed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PhysicsComponentUpdate::clear_has_speed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PhysicsComponentUpdate::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float PhysicsComponentUpdate::speed() const {
  // @@protoc_insertion_point(field_get:PhysicsComponentUpdate.speed)
  return speed_;
}
inline void PhysicsComponentUpdate::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:PhysicsComponentUpdate.speed)
}

// optional bool isColliding = 4;
inline bool PhysicsComponentUpdate::has_iscolliding() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PhysicsComponentUpdate::set_has_iscolliding() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PhysicsComponentUpdate::clear_has_iscolliding() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PhysicsComponentUpdate::clear_iscolliding() {
  iscolliding_ = false;
  clear_has_iscolliding();
}
inline bool PhysicsComponentUpdate::iscolliding() const {
  // @@protoc_insertion_point(field_get:PhysicsComponentUpdate.isColliding)
  return iscolliding_;
}
inline void PhysicsComponentUpdate::set_iscolliding(bool value) {
  set_has_iscolliding();
  iscolliding_ = value;
  // @@protoc_insertion_point(field_set:PhysicsComponentUpdate.isColliding)
}

// optional float velX = 5;
inline bool PhysicsComponentUpdate::has_velx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PhysicsComponentUpdate::set_has_velx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PhysicsComponentUpdate::clear_has_velx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PhysicsComponentUpdate::clear_velx() {
  velx_ = 0;
  clear_has_velx();
}
inline float PhysicsComponentUpdate::velx() const {
  // @@protoc_insertion_point(field_get:PhysicsComponentUpdate.velX)
  return velx_;
}
inline void PhysicsComponentUpdate::set_velx(float value) {
  set_has_velx();
  velx_ = value;
  // @@protoc_insertion_point(field_set:PhysicsComponentUpdate.velX)
}

// optional float velY = 6;
inline bool PhysicsComponentUpdate::has_vely() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PhysicsComponentUpdate::set_has_vely() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PhysicsComponentUpdate::clear_has_vely() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PhysicsComponentUpdate::clear_vely() {
  vely_ = 0;
  clear_has_vely();
}
inline float PhysicsComponentUpdate::vely() const {
  // @@protoc_insertion_point(field_get:PhysicsComponentUpdate.velY)
  return vely_;
}
inline void PhysicsComponentUpdate::set_vely(float value) {
  set_has_vely();
  vely_ = value;
  // @@protoc_insertion_point(field_set:PhysicsComponentUpdate.velY)
}

// optional float posX = 7;
inline bool PhysicsComponentUpdate::has_posx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PhysicsComponentUpdate::set_has_posx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PhysicsComponentUpdate::clear_has_posx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PhysicsComponentUpdate::clear_posx() {
  posx_ = 0;
  clear_has_posx();
}
inline float PhysicsComponentUpdate::posx() const {
  // @@protoc_insertion_point(field_get:PhysicsComponentUpdate.posX)
  return posx_;
}
inline void PhysicsComponentUpdate::set_posx(float value) {
  set_has_posx();
  posx_ = value;
  // @@protoc_insertion_point(field_set:PhysicsComponentUpdate.posX)
}

// optional float posY = 8;
inline bool PhysicsComponentUpdate::has_posy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PhysicsComponentUpdate::set_has_posy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PhysicsComponentUpdate::clear_has_posy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PhysicsComponentUpdate::clear_posy() {
  posy_ = 0;
  clear_has_posy();
}
inline float PhysicsComponentUpdate::posy() const {
  // @@protoc_insertion_point(field_get:PhysicsComponentUpdate.posY)
  return posy_;
}
inline void PhysicsComponentUpdate::set_posy(float value) {
  set_has_posy();
  posy_ = value;
  // @@protoc_insertion_point(field_set:PhysicsComponentUpdate.posY)
}

// -------------------------------------------------------------------

// ProjectileComponentUpdate

// optional int32 damage = 1;
inline bool ProjectileComponentUpdate::has_damage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjectileComponentUpdate::set_has_damage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjectileComponentUpdate::clear_has_damage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjectileComponentUpdate::clear_damage() {
  damage_ = 0;
  clear_has_damage();
}
inline ::google::protobuf::int32 ProjectileComponentUpdate::damage() const {
  // @@protoc_insertion_point(field_get:ProjectileComponentUpdate.damage)
  return damage_;
}
inline void ProjectileComponentUpdate::set_damage(::google::protobuf::int32 value) {
  set_has_damage();
  damage_ = value;
  // @@protoc_insertion_point(field_set:ProjectileComponentUpdate.damage)
}

// optional int32 originEntity = 2;
inline bool ProjectileComponentUpdate::has_originentity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProjectileComponentUpdate::set_has_originentity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProjectileComponentUpdate::clear_has_originentity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProjectileComponentUpdate::clear_originentity() {
  originentity_ = 0;
  clear_has_originentity();
}
inline ::google::protobuf::int32 ProjectileComponentUpdate::originentity() const {
  // @@protoc_insertion_point(field_get:ProjectileComponentUpdate.originEntity)
  return originentity_;
}
inline void ProjectileComponentUpdate::set_originentity(::google::protobuf::int32 value) {
  set_has_originentity();
  originentity_ = value;
  // @@protoc_insertion_point(field_set:ProjectileComponentUpdate.originEntity)
}

// -------------------------------------------------------------------

// ResourceTypeUpdate

// optional string resourceType = 1;
inline bool ResourceTypeUpdate::has_resourcetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceTypeUpdate::set_has_resourcetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceTypeUpdate::clear_has_resourcetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceTypeUpdate::clear_resourcetype() {
  resourcetype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_resourcetype();
}
inline const ::std::string& ResourceTypeUpdate::resourcetype() const {
  // @@protoc_insertion_point(field_get:ResourceTypeUpdate.resourceType)
  return resourcetype_.GetNoArena();
}
inline void ResourceTypeUpdate::set_resourcetype(const ::std::string& value) {
  set_has_resourcetype();
  resourcetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ResourceTypeUpdate.resourceType)
}
#if LANG_CXX11
inline void ResourceTypeUpdate::set_resourcetype(::std::string&& value) {
  set_has_resourcetype();
  resourcetype_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ResourceTypeUpdate.resourceType)
}
#endif
inline void ResourceTypeUpdate::set_resourcetype(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_resourcetype();
  resourcetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ResourceTypeUpdate.resourceType)
}
inline void ResourceTypeUpdate::set_resourcetype(const char* value, size_t size) {
  set_has_resourcetype();
  resourcetype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ResourceTypeUpdate.resourceType)
}
inline ::std::string* ResourceTypeUpdate::mutable_resourcetype() {
  set_has_resourcetype();
  // @@protoc_insertion_point(field_mutable:ResourceTypeUpdate.resourceType)
  return resourcetype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResourceTypeUpdate::release_resourcetype() {
  // @@protoc_insertion_point(field_release:ResourceTypeUpdate.resourceType)
  if (!has_resourcetype()) {
    return NULL;
  }
  clear_has_resourcetype();
  return resourcetype_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResourceTypeUpdate::set_allocated_resourcetype(::std::string* resourcetype) {
  if (resourcetype != NULL) {
    set_has_resourcetype();
  } else {
    clear_has_resourcetype();
  }
  resourcetype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), resourcetype);
  // @@protoc_insertion_point(field_set_allocated:ResourceTypeUpdate.resourceType)
}

// optional int32 resourceStrength = 2;
inline bool ResourceTypeUpdate::has_resourcestrength() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceTypeUpdate::set_has_resourcestrength() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceTypeUpdate::clear_has_resourcestrength() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceTypeUpdate::clear_resourcestrength() {
  resourcestrength_ = 0;
  clear_has_resourcestrength();
}
inline ::google::protobuf::int32 ResourceTypeUpdate::resourcestrength() const {
  // @@protoc_insertion_point(field_get:ResourceTypeUpdate.resourceStrength)
  return resourcestrength_;
}
inline void ResourceTypeUpdate::set_resourcestrength(::google::protobuf::int32 value) {
  set_has_resourcestrength();
  resourcestrength_ = value;
  // @@protoc_insertion_point(field_set:ResourceTypeUpdate.resourceStrength)
}

// -------------------------------------------------------------------

// ResourceComponentUpdate

// repeated .ResourceTypeUpdate resourceType = 1;
inline int ResourceComponentUpdate::resourcetype_size() const {
  return resourcetype_.size();
}
inline void ResourceComponentUpdate::clear_resourcetype() {
  resourcetype_.Clear();
}
inline ::ResourceTypeUpdate* ResourceComponentUpdate::mutable_resourcetype(int index) {
  // @@protoc_insertion_point(field_mutable:ResourceComponentUpdate.resourceType)
  return resourcetype_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ResourceTypeUpdate >*
ResourceComponentUpdate::mutable_resourcetype() {
  // @@protoc_insertion_point(field_mutable_list:ResourceComponentUpdate.resourceType)
  return &resourcetype_;
}
inline const ::ResourceTypeUpdate& ResourceComponentUpdate::resourcetype(int index) const {
  // @@protoc_insertion_point(field_get:ResourceComponentUpdate.resourceType)
  return resourcetype_.Get(index);
}
inline ::ResourceTypeUpdate* ResourceComponentUpdate::add_resourcetype() {
  // @@protoc_insertion_point(field_add:ResourceComponentUpdate.resourceType)
  return resourcetype_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ResourceTypeUpdate >&
ResourceComponentUpdate::resourcetype() const {
  // @@protoc_insertion_point(field_list:ResourceComponentUpdate.resourceType)
  return resourcetype_;
}

// -------------------------------------------------------------------

// HealthComponentUpdate

// optional int32 hp = 1;
inline bool HealthComponentUpdate::has_hp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HealthComponentUpdate::set_has_hp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HealthComponentUpdate::clear_has_hp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HealthComponentUpdate::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 HealthComponentUpdate::hp() const {
  // @@protoc_insertion_point(field_get:HealthComponentUpdate.hp)
  return hp_;
}
inline void HealthComponentUpdate::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:HealthComponentUpdate.hp)
}

// optional int32 maxHp = 2;
inline bool HealthComponentUpdate::has_maxhp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HealthComponentUpdate::set_has_maxhp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HealthComponentUpdate::clear_has_maxhp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HealthComponentUpdate::clear_maxhp() {
  maxhp_ = 0;
  clear_has_maxhp();
}
inline ::google::protobuf::int32 HealthComponentUpdate::maxhp() const {
  // @@protoc_insertion_point(field_get:HealthComponentUpdate.maxHp)
  return maxhp_;
}
inline void HealthComponentUpdate::set_maxhp(::google::protobuf::int32 value) {
  set_has_maxhp();
  maxhp_ = value;
  // @@protoc_insertion_point(field_set:HealthComponentUpdate.maxHp)
}

// -------------------------------------------------------------------

// UpdatedEntity

// optional int32 entityID = 1;
inline bool UpdatedEntity::has_entityid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UpdatedEntity::set_has_entityid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UpdatedEntity::clear_has_entityid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UpdatedEntity::clear_entityid() {
  entityid_ = 0;
  clear_has_entityid();
}
inline ::google::protobuf::int32 UpdatedEntity::entityid() const {
  // @@protoc_insertion_point(field_get:UpdatedEntity.entityID)
  return entityid_;
}
inline void UpdatedEntity::set_entityid(::google::protobuf::int32 value) {
  set_has_entityid();
  entityid_ = value;
  // @@protoc_insertion_point(field_set:UpdatedEntity.entityID)
}

// optional .HealthComponentUpdate health = 2;
inline bool UpdatedEntity::has_health() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdatedEntity::set_has_health() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdatedEntity::clear_has_health() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdatedEntity::clear_health() {
  if (health_ != NULL) health_->Clear();
  clear_has_health();
}
inline const ::HealthComponentUpdate& UpdatedEntity::_internal_health() const {
  return *health_;
}
inline const ::HealthComponentUpdate& UpdatedEntity::health() const {
  const ::HealthComponentUpdate* p = health_;
  // @@protoc_insertion_point(field_get:UpdatedEntity.health)
  return p != NULL ? *p : *reinterpret_cast<const ::HealthComponentUpdate*>(
      &::_HealthComponentUpdate_default_instance_);
}
inline ::HealthComponentUpdate* UpdatedEntity::release_health() {
  // @@protoc_insertion_point(field_release:UpdatedEntity.health)
  clear_has_health();
  ::HealthComponentUpdate* temp = health_;
  health_ = NULL;
  return temp;
}
inline ::HealthComponentUpdate* UpdatedEntity::mutable_health() {
  set_has_health();
  if (health_ == NULL) {
    auto* p = CreateMaybeMessage<::HealthComponentUpdate>(GetArenaNoVirtual());
    health_ = p;
  }
  // @@protoc_insertion_point(field_mutable:UpdatedEntity.health)
  return health_;
}
inline void UpdatedEntity::set_allocated_health(::HealthComponentUpdate* health) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete health_;
  }
  if (health) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      health = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, health, submessage_arena);
    }
    set_has_health();
  } else {
    clear_has_health();
  }
  health_ = health;
  // @@protoc_insertion_point(field_set_allocated:UpdatedEntity.health)
}

// optional .PhysicsComponentUpdate physics = 3;
inline bool UpdatedEntity::has_physics() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdatedEntity::set_has_physics() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdatedEntity::clear_has_physics() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdatedEntity::clear_physics() {
  if (physics_ != NULL) physics_->Clear();
  clear_has_physics();
}
inline const ::PhysicsComponentUpdate& UpdatedEntity::_internal_physics() const {
  return *physics_;
}
inline const ::PhysicsComponentUpdate& UpdatedEntity::physics() const {
  const ::PhysicsComponentUpdate* p = physics_;
  // @@protoc_insertion_point(field_get:UpdatedEntity.physics)
  return p != NULL ? *p : *reinterpret_cast<const ::PhysicsComponentUpdate*>(
      &::_PhysicsComponentUpdate_default_instance_);
}
inline ::PhysicsComponentUpdate* UpdatedEntity::release_physics() {
  // @@protoc_insertion_point(field_release:UpdatedEntity.physics)
  clear_has_physics();
  ::PhysicsComponentUpdate* temp = physics_;
  physics_ = NULL;
  return temp;
}
inline ::PhysicsComponentUpdate* UpdatedEntity::mutable_physics() {
  set_has_physics();
  if (physics_ == NULL) {
    auto* p = CreateMaybeMessage<::PhysicsComponentUpdate>(GetArenaNoVirtual());
    physics_ = p;
  }
  // @@protoc_insertion_point(field_mutable:UpdatedEntity.physics)
  return physics_;
}
inline void UpdatedEntity::set_allocated_physics(::PhysicsComponentUpdate* physics) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete physics_;
  }
  if (physics) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      physics = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, physics, submessage_arena);
    }
    set_has_physics();
  } else {
    clear_has_physics();
  }
  physics_ = physics;
  // @@protoc_insertion_point(field_set_allocated:UpdatedEntity.physics)
}

// optional .ResourceComponentUpdate resource = 16;
inline bool UpdatedEntity::has_resource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdatedEntity::set_has_resource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdatedEntity::clear_has_resource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdatedEntity::clear_resource() {
  if (resource_ != NULL) resource_->Clear();
  clear_has_resource();
}
inline const ::ResourceComponentUpdate& UpdatedEntity::_internal_resource() const {
  return *resource_;
}
inline const ::ResourceComponentUpdate& UpdatedEntity::resource() const {
  const ::ResourceComponentUpdate* p = resource_;
  // @@protoc_insertion_point(field_get:UpdatedEntity.resource)
  return p != NULL ? *p : *reinterpret_cast<const ::ResourceComponentUpdate*>(
      &::_ResourceComponentUpdate_default_instance_);
}
inline ::ResourceComponentUpdate* UpdatedEntity::release_resource() {
  // @@protoc_insertion_point(field_release:UpdatedEntity.resource)
  clear_has_resource();
  ::ResourceComponentUpdate* temp = resource_;
  resource_ = NULL;
  return temp;
}
inline ::ResourceComponentUpdate* UpdatedEntity::mutable_resource() {
  set_has_resource();
  if (resource_ == NULL) {
    auto* p = CreateMaybeMessage<::ResourceComponentUpdate>(GetArenaNoVirtual());
    resource_ = p;
  }
  // @@protoc_insertion_point(field_mutable:UpdatedEntity.resource)
  return resource_;
}
inline void UpdatedEntity::set_allocated_resource(::ResourceComponentUpdate* resource) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resource_;
  }
  if (resource) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resource = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resource, submessage_arena);
    }
    set_has_resource();
  } else {
    clear_has_resource();
  }
  resource_ = resource;
  // @@protoc_insertion_point(field_set_allocated:UpdatedEntity.resource)
}

// optional .ProjectileComponentUpdate projectile = 17;
inline bool UpdatedEntity::has_projectile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UpdatedEntity::set_has_projectile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UpdatedEntity::clear_has_projectile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UpdatedEntity::clear_projectile() {
  if (projectile_ != NULL) projectile_->Clear();
  clear_has_projectile();
}
inline const ::ProjectileComponentUpdate& UpdatedEntity::_internal_projectile() const {
  return *projectile_;
}
inline const ::ProjectileComponentUpdate& UpdatedEntity::projectile() const {
  const ::ProjectileComponentUpdate* p = projectile_;
  // @@protoc_insertion_point(field_get:UpdatedEntity.projectile)
  return p != NULL ? *p : *reinterpret_cast<const ::ProjectileComponentUpdate*>(
      &::_ProjectileComponentUpdate_default_instance_);
}
inline ::ProjectileComponentUpdate* UpdatedEntity::release_projectile() {
  // @@protoc_insertion_point(field_release:UpdatedEntity.projectile)
  clear_has_projectile();
  ::ProjectileComponentUpdate* temp = projectile_;
  projectile_ = NULL;
  return temp;
}
inline ::ProjectileComponentUpdate* UpdatedEntity::mutable_projectile() {
  set_has_projectile();
  if (projectile_ == NULL) {
    auto* p = CreateMaybeMessage<::ProjectileComponentUpdate>(GetArenaNoVirtual());
    projectile_ = p;
  }
  // @@protoc_insertion_point(field_mutable:UpdatedEntity.projectile)
  return projectile_;
}
inline void UpdatedEntity::set_allocated_projectile(::ProjectileComponentUpdate* projectile) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete projectile_;
  }
  if (projectile) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      projectile = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, projectile, submessage_arena);
    }
    set_has_projectile();
  } else {
    clear_has_projectile();
  }
  projectile_ = projectile;
  // @@protoc_insertion_point(field_set_allocated:UpdatedEntity.projectile)
}

// -------------------------------------------------------------------

// UpdatedEntityList

// repeated .UpdatedEntity entities = 1;
inline int UpdatedEntityList::entities_size() const {
  return entities_.size();
}
inline void UpdatedEntityList::clear_entities() {
  entities_.Clear();
}
inline ::UpdatedEntity* UpdatedEntityList::mutable_entities(int index) {
  // @@protoc_insertion_point(field_mutable:UpdatedEntityList.entities)
  return entities_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::UpdatedEntity >*
UpdatedEntityList::mutable_entities() {
  // @@protoc_insertion_point(field_mutable_list:UpdatedEntityList.entities)
  return &entities_;
}
inline const ::UpdatedEntity& UpdatedEntityList::entities(int index) const {
  // @@protoc_insertion_point(field_get:UpdatedEntityList.entities)
  return entities_.Get(index);
}
inline ::UpdatedEntity* UpdatedEntityList::add_entities() {
  // @@protoc_insertion_point(field_add:UpdatedEntityList.entities)
  return entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::UpdatedEntity >&
UpdatedEntityList::entities() const {
  // @@protoc_insertion_point(field_list:UpdatedEntityList.entities)
  return entities_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::UpdatedEntity_UpdateType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UpdatedEntity_UpdateType>() {
  return ::UpdatedEntity_UpdateType_descriptor();
}
template <> struct is_proto_enum< ::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageType>() {
  return ::MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_BaseMessage_2eproto
